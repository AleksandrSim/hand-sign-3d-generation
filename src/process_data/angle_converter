import numpy as np


class XYZToPitchYawRollConverter:
    def __init__(self, npz_path, output_path):
        self.data = np.load(npz_path)['data']  # Load data
        self.output_path = output_path
    
    @staticmethod
    def calculate_direction_vectors(data):
        vectors = np.diff(data, axis=3)
        return vectors
    
    @staticmethod
    def normalize_vectors(vectors):
        norms = np.linalg.norm(vectors, axis=2, keepdims=True)
        normalized_vectors = vectors / norms
        return normalized_vectors
    
    @staticmethod
    def calculate_pitch_yaw(vectors):
        pitch = np.arctan2(vectors[..., 2, :], np.sqrt(vectors[..., 0, :]**2 + vectors[..., 1, :]**2))
        yaw = np.arctan2(vectors[..., 1, :], vectors[..., 0, :])
        return np.degrees(pitch), np.degrees(yaw)
    
    @staticmethod
    def calculate_roll(vectors):
        # Placeholder for Roll calculation. Adjust this method based on your specific data and requirements.
        # This example returns zeros as a placeholder.
        roll = np.zeros(vectors.shape[:-2])
        return np.degrees(roll)
    
    def convert_and_save(self):
        vectors = self.calculate_direction_vectors(self.data)
        normalized_vectors = self.normalize_vectors(vectors)
        pitch, yaw = self.calculate_pitch_yaw(normalized_vectors)
        roll = self.calculate_roll(normalized_vectors)
        
        # Save Pitch, Yaw, and Roll to output path
        np.savez(self.output_path, pitch=pitch, yaw=yaw, roll=roll)
        print(f"Saved Pitch, Yaw, and Roll to {self.output_path}")

npz_path = '/Users/aleksandrsimonyan/Desktop/complete_sequence/unified_data_reverse_inc.npz'
output_path = '/Users/aleksandrsimonyan/Desktop/complete_sequence/unified_data_reverse_inc_pitch_roll_yaw.npz'
converter = XYZToPitchYawRollConverter(npz_path, output_path)
converter.convert_and_save()
